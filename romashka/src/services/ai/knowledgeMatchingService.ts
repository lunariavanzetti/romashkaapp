/**
 * AI-powered knowledge matching service using GPT-4o-mini
 * This service analyzes user questions against extracted knowledge bases
 * and provides intelligent, context-aware responses.
 */

interface KnowledgeMatchRequest {
  question: string;
  knowledgeBase: string;
  agentTone?: string;
  businessType?: string;
}

interface KnowledgeMatchResponse {
  answer: string | null;
  confidence: number;
  sources?: string[];
}

class KnowledgeMatchingService {
  private readonly apiKey: string;
  private readonly apiUrl = 'https://api.openai.com/v1/chat/completions';

  constructor() {
    this.apiKey = import.meta.env.VITE_OPENAI_API_KEY;
    if (!this.apiKey) {
      console.error('OpenAI API key not found in environment variables');
    }
  }

  /**
   * Find the best answer for a user question using AI analysis
   */
  async findAnswer(request: KnowledgeMatchRequest): Promise<KnowledgeMatchResponse> {
    try {
      console.log('🔍 AI Knowledge Matching:', request.question);
      console.log('📝 Knowledge base length:', request.knowledgeBase.length);

      if (!this.apiKey) {
        throw new Error('OpenAI API key not configured');
      }

      const systemPrompt = this.buildSystemPrompt(request.agentTone, request.businessType);
      const userPrompt = this.buildUserPrompt(request.question, request.knowledgeBase);

      const response = await fetch(this.apiUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userPrompt }
          ],
          max_tokens: 800,
          temperature: 0.3,
          top_p: 0.9,
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('OpenAI API error:', response.status, errorText);
        throw new Error(`OpenAI API error: ${response.status}`);
      }

      const data = await response.json();
      const answer = data.choices[0]?.message?.content;

      if (!answer) {
        console.log('❌ No answer generated by AI');
        return { answer: null, confidence: 0 };
      }

      // Check if AI indicates no relevant information found
      const lowerAnswer = answer.toLowerCase();
      if (lowerAnswer.includes('no relevant information') || 
          lowerAnswer.includes('cannot find') ||
          lowerAnswer.includes('not found in') ||
          answer.trim() === 'null') {
        console.log('❌ AI found no relevant information');
        return { answer: null, confidence: 0 };
      }

      console.log('✅ AI knowledge match found:', answer.substring(0, 100) + '...');
      
      // Estimate confidence based on answer quality
      const confidence = this.estimateConfidence(answer, request.question);
      
      return {
        answer: answer.trim(),
        confidence,
        sources: this.extractSources(answer)
      };

    } catch (error) {
      console.error('❌ Knowledge matching error:', error);
      return { answer: null, confidence: 0 };
    }
  }

  /**
   * Build the system prompt for the AI
   */
  private buildSystemPrompt(agentTone?: string, businessType?: string): string {
    const tone = agentTone || 'helpful and professional';
    const business = businessType || 'general business';

    return `You are a ${tone} customer service assistant for a ${business} business. Your job is to provide natural, conversational answers based ONLY on the provided knowledge base.

CRITICAL INSTRUCTIONS:
1. SPEAK AS IF YOU KNOW THE INFORMATION PERSONALLY - Don't say "I found this" or "according to our information"
2. Answer NATURALLY as if you work for this company and know these policies by heart
3. Use a ${tone} tone and be conversational
4. Give CONCISE, direct answers - don't repeat information
5. If no relevant information exists, say "I don't have that information available"
6. NEVER make up information not in the knowledge base
7. Sound human and personal, not like a search engine

EXAMPLES:
❌ BAD: "I found this for you: Our editing fee does not include..."
✅ GOOD: "Our editing fee doesn't include brush adjustments, radial filters, graduated filters, skin smoothing, or spot removal."

❌ BAD: "Based on our information, we generally use..."
✅ GOOD: "We use Temperature/Tint, Exposure, Highlight Recovery, Shadows, and White/Black Clipping in Lightroom."

IMPORTANT: Sound natural and personal, like you're speaking directly to the customer as a knowledgeable team member.`;
  }

  /**
   * Build the user prompt with question and knowledge base
   */
  private buildUserPrompt(question: string, knowledgeBase: string): string {
    return `CUSTOMER QUESTION:
${question}

KNOWLEDGE BASE:
${knowledgeBase}

Please provide a helpful answer based on the knowledge base above. If the information isn't available, let me know that you don't have that information.`;
  }

  /**
   * Estimate confidence based on answer quality indicators
   */
  private estimateConfidence(answer: string, question: string): number {
    let confidence = 0.5; // Base confidence

    // Higher confidence for longer, detailed answers
    if (answer.length > 200) confidence += 0.2;
    if (answer.length > 500) confidence += 0.1;

    // Higher confidence for structured answers
    if (answer.includes('1.') || answer.includes('•') || answer.includes('-')) {
      confidence += 0.1;
    }

    // Higher confidence for specific details
    if (answer.includes('according to') || answer.includes('as mentioned')) {
      confidence += 0.1;
    }

    // Lower confidence for vague answers
    if (answer.includes('might') || answer.includes('possibly') || answer.includes('perhaps')) {
      confidence -= 0.1;
    }

    return Math.min(Math.max(confidence, 0), 1);
  }

  /**
   * Extract potential sources from the answer
   */
  private extractSources(answer: string): string[] {
    const sources: string[] = [];
    
    // Look for mentions of specific sections or documents
    const sourcePatterns = [
      /section \d+/gi,
      /guide for applicants/gi,
      /FAQ/gi,
      /documentation/gi,
      /according to [^.]+/gi
    ];

    sourcePatterns.forEach(pattern => {
      const matches = answer.match(pattern);
      if (matches) {
        sources.push(...matches);
      }
    });

    return [...new Set(sources)]; // Remove duplicates
  }
}

export const knowledgeMatchingService = new KnowledgeMatchingService();
export default knowledgeMatchingService;