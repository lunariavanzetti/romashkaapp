/**
 * AI-powered knowledge matching service using GPT-4o-mini
 * This service analyzes user questions against extracted knowledge bases
 * and provides intelligent, context-aware responses.
 */

interface KnowledgeMatchRequest {
  question: string;
  knowledgeBase: string;
  agentTone?: string;
  businessType?: string;
}

interface KnowledgeMatchResponse {
  answer: string | null;
  confidence: number;
  sources?: string[];
}

class KnowledgeMatchingService {
  private readonly apiKey: string;
  private readonly apiUrl = 'https://api.openai.com/v1/chat/completions';

  constructor() {
    this.apiKey = import.meta.env.VITE_OPENAI_API_KEY;
    if (!this.apiKey) {
      console.error('OpenAI API key not found in environment variables');
    }
  }

  /**
   * Find the best answer for a user question using AI analysis
   */
  async findAnswer(request: KnowledgeMatchRequest): Promise<KnowledgeMatchResponse> {
    try {
      console.log('ðŸ” AI Knowledge Matching:', request.question);
      console.log('ðŸ“ Knowledge base length:', request.knowledgeBase.length);

      if (!this.apiKey) {
        throw new Error('OpenAI API key not configured');
      }

      const systemPrompt = this.buildSystemPrompt(request.agentTone, request.businessType);
      const userPrompt = this.buildUserPrompt(request.question, request.knowledgeBase);

      const response = await fetch(this.apiUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userPrompt }
          ],
          max_tokens: 800,
          temperature: 0.3,
          top_p: 0.9,
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('OpenAI API error:', response.status, errorText);
        throw new Error(`OpenAI API error: ${response.status}`);
      }

      const data = await response.json();
      const answer = data.choices[0]?.message?.content;

      if (!answer) {
        console.log('âŒ No answer generated by AI');
        return { answer: null, confidence: 0 };
      }

      // Check if AI indicates no relevant information found
      const lowerAnswer = answer.toLowerCase();
      if (lowerAnswer.includes('no relevant information') || 
          lowerAnswer.includes('cannot find') ||
          lowerAnswer.includes('not found in') ||
          answer.trim() === 'null') {
        console.log('âŒ AI found no relevant information');
        return { answer: null, confidence: 0 };
      }

      console.log('âœ… AI knowledge match found:', answer.substring(0, 100) + '...');
      
      // Estimate confidence based on answer quality
      const confidence = this.estimateConfidence(answer, request.question);
      
      return {
        answer: answer.trim(),
        confidence,
        sources: this.extractSources(answer)
      };

    } catch (error) {
      console.error('âŒ Knowledge matching error:', error);
      return { answer: null, confidence: 0 };
    }
  }

  /**
   * Build the system prompt for the AI
   */
  private buildSystemPrompt(agentTone?: string, businessType?: string): string {
    const tone = agentTone || 'helpful and professional';
    const business = businessType || 'general business';

    return `You are a ${tone} customer service assistant for a ${business} business. Your job is to analyze customer questions and provide accurate answers based ONLY on the provided knowledge base.

INSTRUCTIONS:
1. Analyze the customer's question carefully
2. Search through the knowledge base for relevant information
3. If you find relevant information, provide a complete, helpful answer
4. Use a ${tone} tone in your response
5. If the knowledge base contains step-by-step instructions, include them fully
6. If no relevant information exists, respond with "I don't have that information in my knowledge base"
7. NEVER make up information not in the knowledge base
8. Format your response clearly and professionally
9. Be conversational but accurate

IMPORTANT: Base your answer ONLY on the provided knowledge base content. Do not add external knowledge.`;
  }

  /**
   * Build the user prompt with question and knowledge base
   */
  private buildUserPrompt(question: string, knowledgeBase: string): string {
    return `CUSTOMER QUESTION:
${question}

KNOWLEDGE BASE:
${knowledgeBase}

Please provide a helpful answer based on the knowledge base above. If the information isn't available, let me know that you don't have that information.`;
  }

  /**
   * Estimate confidence based on answer quality indicators
   */
  private estimateConfidence(answer: string, question: string): number {
    let confidence = 0.5; // Base confidence

    // Higher confidence for longer, detailed answers
    if (answer.length > 200) confidence += 0.2;
    if (answer.length > 500) confidence += 0.1;

    // Higher confidence for structured answers
    if (answer.includes('1.') || answer.includes('â€¢') || answer.includes('-')) {
      confidence += 0.1;
    }

    // Higher confidence for specific details
    if (answer.includes('according to') || answer.includes('as mentioned')) {
      confidence += 0.1;
    }

    // Lower confidence for vague answers
    if (answer.includes('might') || answer.includes('possibly') || answer.includes('perhaps')) {
      confidence -= 0.1;
    }

    return Math.min(Math.max(confidence, 0), 1);
  }

  /**
   * Extract potential sources from the answer
   */
  private extractSources(answer: string): string[] {
    const sources: string[] = [];
    
    // Look for mentions of specific sections or documents
    const sourcePatterns = [
      /section \d+/gi,
      /guide for applicants/gi,
      /FAQ/gi,
      /documentation/gi,
      /according to [^.]+/gi
    ];

    sourcePatterns.forEach(pattern => {
      const matches = answer.match(pattern);
      if (matches) {
        sources.push(...matches);
      }
    });

    return [...new Set(sources)]; // Remove duplicates
  }
}

export const knowledgeMatchingService = new KnowledgeMatchingService();
export default knowledgeMatchingService;